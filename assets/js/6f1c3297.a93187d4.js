"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4133],{4137:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=o,v=d["".concat(s,".").concat(m)]||d[m]||p[m]||a;return t?r.createElement(v,i(i({ref:n},u),{},{components:t})):r.createElement(v,i({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9647:function(e,n,t){var r=t(7294);n.Z=function(e){var n=e.children,t=e.hidden,o=e.className;return r.createElement("div",{role:"tabpanel",hidden:t,className:o},n)}},7225:function(e,n,t){t.d(n,{Z:function(){return d}});var r=t(7462),o=t(7294),a=t(1048),i=t(2713);var l=function(){var e=(0,o.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=t(3309),c=t(6010),u="tabItem_1uMI";function p(e){var n,t,r,a=e.lazy,i=e.block,p=e.defaultValue,d=e.values,m=e.groupId,v=e.className,f=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),b=null!=d?d:f.map((function(e){var n=e.props;return{value:n.value,label:n.label}})),y=(0,s.lx)(b,(function(e,n){return e.value===n.value}));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var h=null===p?p:null!=(n=null!=p?p:null==(t=f.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(r=f[0])?void 0:r.props.value;if(null!==h&&!b.some((function(e){return e.value===h})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+h+'" but none of its children has the corresponding value. Available values are: '+b.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var k=l(),g=k.tabGroupChoices,w=k.setTabGroupChoices,T=(0,o.useState)(h),O=T[0],N=T[1],x=[],E=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var j=g[m];null!=j&&j!==O&&b.some((function(e){return e.value===j}))&&N(j)}var S=function(e){var n=e.currentTarget,t=x.indexOf(n),r=b[t].value;r!==O&&(E(n),N(r),null!=m&&w(m,r))},I=function(e){var n,t=null;switch(e.key){case"ArrowRight":var r=x.indexOf(e.currentTarget)+1;t=x[r]||x[0];break;case"ArrowLeft":var o=x.indexOf(e.currentTarget)-1;t=x[o]||x[x.length-1]}null==(n=t)||n.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":i},v)},b.map((function(e){var n=e.value,t=e.label;return o.createElement("li",{role:"tab",tabIndex:O===n?0:-1,"aria-selected":O===n,className:(0,c.Z)("tabs__item",u,{"tabs__item--active":O===n}),key:n,ref:function(e){return x.push(e)},onKeyDown:I,onFocus:S,onClick:S},null!=t?t:n)}))),a?(0,o.cloneElement)(f.filter((function(e){return e.props.value===O}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},f.map((function(e,n){return(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==O})}))))}function d(e){var n=(0,a.Z)();return o.createElement(p,(0,r.Z)({key:String(n)},e))}},2713:function(e,n,t){var r=(0,t(7294).createContext)(void 0);n.Z=r},4646:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return u},metadata:function(){return p},toc:function(){return d},default:function(){return v}});var r=t(7462),o=t(3366),a=(t(7294),t(4137)),i=t(7225),l=t(9647),s=["components"],c={id:"scopes",title:"Scopes"},u=void 0,p={unversionedId:"di/scopes",id:"di/scopes",isDocsHomePage:!1,title:"Scopes",description:"Scope defines a life cycle of Providers and InjectionToken. There are two kinds of scopes, Singleton and Operation, former is used by default.",source:"@site/docs/di/scopes.md",sourceDirName:"di",slug:"/di/scopes",permalink:"/docs/di/scopes",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/docs/di/scopes.md",tags:[],version:"current",frontMatter:{id:"scopes",title:"Scopes"},sidebar:"docs",previous:{title:"Providers and Tokens",permalink:"/docs/di/providers"},next:{title:"Subscriptions",permalink:"/docs/advanced/subscriptions"}},d=[{value:"Singleton",id:"singleton",children:[],level:2},{value:"Operation",id:"operation",children:[],level:2},{value:"Using both",id:"using-both",children:[],level:2}],m={toc:d};function v(e){var n=e.components,t=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Scope defines a life cycle of ",(0,a.kt)("inlineCode",{parentName:"p"},"Providers")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"InjectionToken"),". There are two kinds of scopes, ",(0,a.kt)("strong",{parentName:"p"},"Singleton")," and ",(0,a.kt)("strong",{parentName:"p"},"Operation"),", former is used by default."),(0,a.kt)("h2",{id:"singleton"},"Singleton"),(0,a.kt)("p",null,"As mentioned before, ",(0,a.kt)("inlineCode",{parentName:"p"},"Singleton")," scope is the default choice in GraphQL Modules. Every Service and Token is created even before the first incoming GraphQL operation and never gets destroyed (only when Node process is terminated)."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We decided to make it the default choice, because of performance related reasons. In most cases, there's no need to instantiate classes on every new request and dispose them later on.")),(0,a.kt)(i.Z,{defaultValue:"service",values:[{label:"Service",value:"service"},{label:"Factory Provider",value:"factory"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"service",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Injectable, createModule } from 'graphql-modules';\n\n@Injectable()\nclass Data {}\n\nexport const myModule = createModule({\n  id: 'my-module',\n  providers: [Data],\n  /* ... */\n});\n"))),(0,a.kt)(l.Z,{value:"factory",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Injectable, InjectionToken, createModule } from 'graphql-modules';\n\nconst Env = new InjectionToken<'production' | 'development'>('environment');\n\nexport const myModule = createModule({\n  id: 'my-module',\n  providers: [\n    {\n      provide: Env,\n      useFactory() {\n        return process.env.NODE_ENV === 'production'\n          ? 'production'\n          : 'development';\n      },\n    },\n  ],\n  /* ... */\n});\n")))),(0,a.kt)("h2",{id:"operation"},"Operation"),(0,a.kt)("p",null,"All classes and values are created within the context of execution, meaning every incoming GraphQL Operation."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Because of performance related reasons, we recommend to use Singletons whenever possible.")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Data")," class defined below gets instantiated for every new GraphQL operation and disposed once the operation is resolved. Operation Scope doesn't overlap for incoming requests, so for 3 requests at a time, 3 instances of ",(0,a.kt)("inlineCode",{parentName:"p"},"Data")," are created, one per each request."),(0,a.kt)("p",null,"To improve the performance a bit, GraphQL Modules instantiate services on demand. When ",(0,a.kt)("inlineCode",{parentName:"p"},"Data")," is not called anywhere directly or indirectly by resolvers, the service is not created."),(0,a.kt)("p",null,"All services and tokens are destroyed right after GraphQL execution phase."),(0,a.kt)(i.Z,{defaultValue:"service",values:[{label:"Service",value:"service"},{label:"Factory Provider",value:"factory"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"service",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Injectable, Scope, createModule } from 'graphql-modules';\n\n@Injectable({\n  scope: Scope.Operation, // <- here\n})\nclass Data {}\n\nexport const myModule = createModule({\n  id: 'my-module',\n  providers: [Data],\n  /* ... */\n});\n"))),(0,a.kt)(l.Z,{value:"factory",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  Injectable,\n  Scope,\n  InjectionToken,\n  createModule,\n} from 'graphql-modules';\n\nconst Env = new InjectionToken<'production' | 'development'>('environment');\n\nexport const myModule = createModule({\n  id: 'my-module',\n  providers: [\n    {\n      provide: Env,\n      scope: Scope.Operation, // <- here\n      useFactory() {\n        return process.env.NODE_ENV === 'production'\n          ? 'production'\n          : 'development';\n      },\n    },\n  ],\n  /* ... */\n});\n")))),(0,a.kt)("h2",{id:"using-both"},"Using both"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Directly")," accessing a Singleton service in an Operation scoped service is possible, but not the other way around."),(0,a.kt)("p",null,"With ",(0,a.kt)("a",{parentName:"p",href:"/docs/advanced/execution-context"},(0,a.kt)("inlineCode",{parentName:"a"},"@ExecutionContext"))," decorator, your Singleton services will be able to ",(0,a.kt)("strong",{parentName:"p"},"indirectly")," access Operation scoped Tokens and Services."))}v.isMDXComponent=!0}}]);