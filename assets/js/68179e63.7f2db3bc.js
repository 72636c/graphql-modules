"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3412],{4137:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||i;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=d;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:o,s[1]=a;for(var u=2;u<i;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9170:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var r=n(7462),o=n(3366),i=(n(7294),n(4137)),s=["components"],a={id:"resolvers-composition",title:"Resolvers Composition",sidebar_label:"Resolvers Composition"},l=void 0,u={unversionedId:"introduction/resolvers-composition",id:"version-legacy/introduction/resolvers-composition",isDocsHomePage:!1,title:"Resolvers Composition",description:"GraphQL Modules has another powerful feature called 'Resolvers Composition'.",source:"@site/versioned_docs/version-legacy/introduction/resolvers-composition.md",sourceDirName:"introduction",slug:"/introduction/resolvers-composition",permalink:"/docs/legacy/introduction/resolvers-composition",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/versioned_docs/version-legacy/introduction/resolvers-composition.md",version:"legacy",frontMatter:{id:"resolvers-composition",title:"Resolvers Composition",sidebar_label:"Resolvers Composition"},sidebar:"version-legacy/docs",previous:{title:"Context",permalink:"/docs/legacy/introduction/context"},next:{title:"Subscriptions",permalink:"/docs/legacy/introduction/subscriptions"}},c=[{value:"With Basic Resolvers",id:"with-basic-resolvers",children:[]}],p={toc:c};function d(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"GraphQL Modules has another powerful feature called 'Resolvers Composition'.\nWith this feature, you can easily make sure each of your modules only performs the business logic it needs to do, and does not perform unrelated operations."),(0,i.kt)("h2",{id:"with-basic-resolvers"},"With Basic Resolvers"),(0,i.kt)("p",null,"For example, if you have a simple server with authentication and you wish to make sure that one of your queries is protected and only allowed for authenticated users with the ",(0,i.kt)("inlineCode",{parentName:"p"},"EDITOR")," role, your resolver needs to verify these rules as well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const resolvers = {\n  Query: {\n    myQuery: (root, args, context) => {\n      // Make sure that the user is authenticated\n      if (!context.currentUser) {\n        throw new Error('You are not authenticated!');\n      }\n\n      // Make sure that the user has the correct roles\n      if (\n        !context.currentUser.roles ||\n        !context.currentUser.roles.includes('EDITOR')\n      ) {\n        throw new Error('You are not authorized!');\n      }\n\n      // Business logic\n      if (args.something === '1') {\n        return true;\n      }\n\n      return false;\n    },\n  },\n};\n")),(0,i.kt)("p",null,"But the authorization checks are not part of your business logic;\nthey're just part of the flow that you should run before accessing your resolver."),(0,i.kt)("p",null,"GraphQL Modules lets you separate these concerns: you can implement only the business logic of your resolver and then the app that consumes the module will wrap the resolver with custom logic."),(0,i.kt)("p",null,"The concept is similar to that of ",(0,i.kt)("strong",{parentName:"p"},"middleware"),"."),(0,i.kt)("p",null,"Let's strip the resolver of all the unnecessary code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const resolvers = {\n  Query: {\n    myQuery: (root, args, context) => {\n      if (args.something === '1') {\n        return true;\n      }\n\n      return false;\n    },\n  },\n};\n")),(0,i.kt)("p",null,"And let's create utility functions in different files with the logic we have removed here."),(0,i.kt)("p",null,"We can implement authentication and authorization just like GraphQL resolvers; we need to tell GraphQL Modules that the process has succeeded by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export const isAuthenticated = () => (next) => async (\n  root,\n  args,\n  context,\n  info\n) => {\n  if (!context.currentUser) {\n    throw new Error('You are not authenticated!');\n  }\n\n  return next(root, args, context, info);\n};\n\nexport const hasRole = (role: string) => (next) => async (\n  root,\n  args,\n  context,\n  info\n) => {\n  if (!context.currentUser.roles || !context.currentUser.roles.includes(role)) {\n    throw new Error('You are not authorized!');\n  }\n\n  return next(root, args, context, info);\n};\n")),(0,i.kt)("p",null,"Now in our ",(0,i.kt)("inlineCode",{parentName:"p"},"GraphQLModule")," declaration, let's add ",(0,i.kt)("inlineCode",{parentName:"p"},"resolversComposition")," with a map from ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeName.fieldName")," to the function/functions we wish to wrap the resolver with."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { GraphQLModule } from '@graphql-modules/core';\n\nconst MyModule = new GraphQLModule({\n  /*...*/\n  resolversComposition: {\n    'Query.myQuery': [isAuthenticated(), hasRole('EDITOR')],\n  },\n});\n")),(0,i.kt)("p",null,"Before each execution of the ",(0,i.kt)("inlineCode",{parentName:"p"},"myQuery")," resolver, GraphQL Modules makes sure to execute ",(0,i.kt)("inlineCode",{parentName:"p"},"isAuthenticated")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"hasRole"),"."),(0,i.kt)("p",null,"Furthermore, if our logic applies to more than one resolver under ",(0,i.kt)("inlineCode",{parentName:"p"},"Query"),", we can use wild cards."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { GraphQLModule } from '@graphql-modules/core';\n\nconst MyModule = new GraphQLModule({\n  /*...*/\n  resolversComposition: {\n    'Query.*': [isAuthenticated(), hasRole('EDITOR')],\n  },\n});\n")),(0,i.kt)("p",null,"In this case, Before each execution of any resolver under ",(0,i.kt)("inlineCode",{parentName:"p"},"Query"),", GraphQL Modules makes sure to execute ",(0,i.kt)("inlineCode",{parentName:"p"},"isAuthenticated")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"hasRole"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This feature is useful for things like authentication, authorization, permissions, keeping things like last activity, verifying that objects exist and a lot more!")),(0,i.kt)("p",null,"The great thing about resolvers composition is that each of our resolvers just does its own job without unrelated logic and the app can extend resolvers later on arbitrary rules."),(0,i.kt)("p",null,"Now it's easier to re-use modules: you can implement the logic once and wrap it with different rules later."))}d.isMDXComponent=!0}}]);