"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4140],{4137:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=a.createContext({}),s=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=s(t),m=o,v=d["".concat(u,".").concat(m)]||d[m]||p[m]||r;return t?a.createElement(v,l(l({ref:n},c),{},{components:t})):a.createElement(v,l({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,l=new Array(r);l[0]=d;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9647:function(e,n,t){var a=t(7294);n.Z=function(e){var n=e.children,t=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",hidden:t,className:o},n)}},7225:function(e,n,t){t.d(n,{Z:function(){return d}});var a=t(7462),o=t(7294),r=t(1048),l=t(2713);var i=function(){var e=(0,o.useContext)(l.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},u=t(3309),s=t(6010),c="tabItem_1uMI";function p(e){var n,t,a,r=e.lazy,l=e.block,p=e.defaultValue,d=e.values,m=e.groupId,v=e.className,h=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=d?d:h.map((function(e){var n=e.props;return{value:n.value,label:n.label}})),y=(0,u.lx)(f,(function(e,n){return e.value===n.value}));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var k=null===p?p:null!=(n=null!=p?p:null==(t=h.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(a=h[0])?void 0:a.props.value;if(null!==k&&!f.some((function(e){return e.value===k})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var g=i(),b=g.tabGroupChoices,w=g.setTabGroupChoices,M=(0,o.useState)(k),N=M[0],T=M[1],x=[],I=(0,u.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var C=b[m];null!=C&&C!==N&&f.some((function(e){return e.value===C}))&&T(C)}var j=function(e){var n=e.currentTarget,t=x.indexOf(n),a=f[t].value;a!==N&&(I(n),T(a),null!=m&&w(m,a))},O=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a=x.indexOf(e.currentTarget)+1;t=x[a]||x[0];break;case"ArrowLeft":var o=x.indexOf(e.currentTarget)-1;t=x[o]||x[x.length-1]}null==(n=t)||n.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":l},v)},f.map((function(e){var n=e.value,t=e.label;return o.createElement("li",{role:"tab",tabIndex:N===n?0:-1,"aria-selected":N===n,className:(0,s.Z)("tabs__item",c,{"tabs__item--active":N===n}),key:n,ref:function(e){return x.push(e)},onKeyDown:O,onFocus:j,onClick:j},null!=t?t:n)}))),r?(0,o.cloneElement)(h.filter((function(e){return e.props.value===N}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},h.map((function(e,n){return(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==N})}))))}function d(e){var n=(0,r.Z)();return o.createElement(p,(0,a.Z)({key:String(n)},e))}},2713:function(e,n,t){var a=(0,t(7294).createContext)(void 0);n.Z=a},6994:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return d},default:function(){return v}});var a=t(7462),o=t(3366),r=(t(7294),t(4137)),l=t(7225),i=t(9647),u=["components"],s={id:"migration",title:"Migration from v0.X"},c=void 0,p={unversionedId:"recipes/migration",id:"recipes/migration",isDocsHomePage:!1,title:"Migration from v0.X",description:"Note: this page is still in progress!",source:"@site/docs/recipes/migration.md",sourceDirName:"recipes",slug:"/recipes/migration",permalink:"/docs/recipes/migration",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/docs/recipes/migration.md",tags:[],version:"current",frontMatter:{id:"migration",title:"Migration from v0.X"},sidebar:"docs",previous:{title:"Solve N+1 Using DataLoader",permalink:"/docs/recipes/dataloader"},next:{title:"API Reference",permalink:"/docs/api"}},d=[{value:"Package name",id:"package-name",children:[],level:2},{value:"<code>DocumentNode</code> for <code>typeDefs</code>",id:"documentnode-for-typedefs",children:[],level:2},{value:"Classes to Utility Functions",id:"classes-to-utility-functions",children:[],level:2},{value:"Resolvers Composition =&gt; Middleware",id:"resolvers-composition--middleware",children:[],level:2},{value:"Module/Application Structure",id:"moduleapplication-structure",children:[],level:2},{value:"Shared Injectables",id:"shared-injectables",children:[],level:2},{value:"Module Config",id:"module-config",children:[],level:2},{value:"Session",id:"session",children:[],level:2},{value:"Context",id:"context",children:[],level:2},{value:"Dependency Injection Scopes",id:"dependency-injection-scopes",children:[],level:2},{value:"Dependency Injection Hierarchy",id:"dependency-injection-hierarchy",children:[],level:2}],m={toc:d};function v(e){var n=e.components,t=(0,o.Z)(e,u);return(0,r.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: this page is still in progress!")),(0,r.kt)("h2",{id:"package-name"},"Package name"),(0,r.kt)("p",null,"We decided to merge two existing packages ",(0,r.kt)("inlineCode",{parentName:"p"},"@graphql-modules/core")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@graphql-modules/di")," into a single package ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-modules"),".\nThere's no regression in terms of bundle size, because ",(0,r.kt)("inlineCode",{parentName:"p"},"core")," was importing ",(0,r.kt)("inlineCode",{parentName:"p"},"di")," anyway."),(0,r.kt)("p",null,"Making GraphQL Modules a single package should improve the developer experience."),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { gql, createModule, Injectable } from 'graphql-modules';\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { GraphQLModule } from '@graphql-modules/core`;\nimport { Injectable } from '@graphql-modules/di`;\nimport gql from 'graphql-tag';\n")))),(0,r.kt)("h2",{id:"documentnode-for-typedefs"},(0,r.kt)("inlineCode",{parentName:"h2"},"DocumentNode")," for ",(0,r.kt)("inlineCode",{parentName:"h2"},"typeDefs")),(0,r.kt)("p",null,"v0 accepted ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDefs"),", while v1 doesn't."),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { gql, createModule } from 'graphql-modules';\n\nconst myModule = createModule({\n  /// ...\n  typeDefs: gql`\n    type Query {\n      foo: String\n    }\n  `,\n});\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const myModule = GraphQLModule({\n  // ...\n  typeDefs: `type Query { foo: String }`,\n});\n")))),(0,r.kt)("h2",{id:"classes-to-utility-functions"},"Classes to Utility Functions"),(0,r.kt)("p",null,"You no longer need to create ",(0,r.kt)("inlineCode",{parentName:"p"},"new GraphQLModule()"),", you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"createModule")," instead:"),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const myModule = createModule({ ... });\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const myModule = new GraphQLModule({ ... });\n")))),(0,r.kt)("h2",{id:"resolvers-composition--middleware"},"Resolvers Composition => Middleware"),(0,r.kt)("p",null,"With version ",(0,r.kt)("inlineCode",{parentName:"p"},"0.x")," we had resolvers-composition, which was our way to define wrappers for resolvers."),(0,r.kt)("p",null,"In v1, we changed the name to Middlewares, and changed the API a bit, to make it more flexible and more compatible with similar middlewares implementations:"),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("p",null,"To define:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function yourMiddleware({ root, args, context, info }, next) {\n  /* code */\n\n  return next();\n}\n")),(0,r.kt)("p",null,"To use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const myModule = createModule({\n  // ...\n  middlwares: {\n    Query: {\n      me: [yourMiddleware],\n    },\n  },\n});\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("p",null,"To define:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export const yourMiddleware = () => (next) => async (\n  root,\n  args,\n  context,\n  info\n) => {\n  /* code */\n\n  return next(root, args, context, info);\n};\n")),(0,r.kt)("p",null,"To use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const myModule = new GraphQLModule({\n  /*...*/\n  resolversComposition: {\n    'Query.me': [yourMiddleware],\n  },\n});\n")))),(0,r.kt)("h2",{id:"moduleapplication-structure"},"Module/Application Structure"),(0,r.kt)("p",null,"With version ",(0,r.kt)("inlineCode",{parentName:"p"},"0.x")," of GraphQL Modules, we were trying to make modules more dynamic, and build a hierarchy tree of dependencies between modules. This wasn't a great solution for all use-cases, and made things complicated."),(0,r.kt)("p",null,"In v1, we changed behavior modules to be flat, and added ",(0,r.kt)("inlineCode",{parentName:"p"},"Application")," to define the root of injection."),(0,r.kt)("p",null,"You no longer need to define ",(0,r.kt)("inlineCode",{parentName:"p"},"imports")," and define strict dependencies between modules, since they are all flatten and merged together by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Application"),"."),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const moduleOne = createModule({ ... });\nconst moduleTwo = createModule({ ... });\n\nconst application = createApplication({\n  modules: [moduleOne, moduleTwo]\n})\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const moduleOne = new GraphQLModule({ ... });\nconst moduleTwo = new GraphQLModule({ imports: [moduleOne], ...})\n\nconst rootModule = new GraphQLModule({\n  imports: [moduleTwo],\n})\n")))),(0,r.kt)("h2",{id:"shared-injectables"},"Shared Injectables"),(0,r.kt)("p",null,"In V0, you needed to create an ",(0,r.kt)("inlineCode",{parentName:"p"},"Injectable"),", add it to a module, and then in order to consume it in another module, you needed to make sure you have a dependency (with ",(0,r.kt)("inlineCode",{parentName:"p"},"imports"),") between your modules. This was very strict and made development harder."),(0,r.kt)("p",null,"Since we moved to a flatten structure of ",(0,r.kt)("inlineCode",{parentName:"p"},"Application"),", all you need to do in order to share an ",(0,r.kt)("inlineCode",{parentName:"p"},"Injectable"),", is just to add ",(0,r.kt)("inlineCode",{parentName:"p"},"global: true"),":"),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Module 1\n\n@Injectable({\n  global: true\n})\nclass MyProvider {\n  // ...\n}\n\nconst moduleOne = createModule({ providers: [MyProvider] });\n\n// Module 2\n@Injectable()\nclass MyOtherProvider {\n  constructor(myProvider: MyProvider) {\n\n  }\n}\n\nconst moduleTwo = createModule({ ... });\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Module 1\n\n@Injectable()\nclass MyProvider {\n  // ...\n}\n\nconst moduleOne = new GraphQLModule({\n  providers: [MyProvider],\n});\n\n// Module 2\n@Injectable()\nclass MyOtherProvider {\n  constructor(myProvider: MyProvider) {}\n}\nconst moduleTwo = new GraphQLModule({ imports: [moduleOne] });\n\nconst rootModule = new GraphQLModule({\n  imports: [moduleTwo],\n});\n")))),(0,r.kt)("h2",{id:"module-config"},"Module Config"),(0,r.kt)("p",null,"In V0, we had the concept of ",(0,r.kt)("inlineCode",{parentName:"p"},"ModuleConfig")," which was a very specific way to instantiate a module with configuration."),(0,r.kt)("p",null,"In V1, it's no longer exists, and we believe there are simpler way to do that, with custom tokens."),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModule, InjectionToken } from '@graphql-modules/core';\n\nexport interface MyModuleConfig {\n  secretKey: string;\n  remoteEndpoint: string;\n  someDbInstance: SomeDBInstance;\n}\n\nexport const MyConfig = new InjectionToken<MyModuleConfig>();\n\nexport const createMyModule = (config: MyModuleConfig) =>\n  createModule({\n    // ...\n    providers: [\n      {\n        provide: MyConfig,\n        useValue: config,\n      },\n    ],\n  });\n\nconst application = createApplication({\n  modules: [\n    createMyModule({\n      secretKey: '123',\n      remoteEndpoint: 'http://...',\n      someDbInstance: db,\n    }),\n  ],\n});\n")),(0,r.kt)("p",null,"And to consume, that same way as in V0:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Injectable()\nexport class MyProvider {\n  constructor(@Inject(MyConfig) private config: MyModuleConfig) {\n    // ...\n  }\n}\n"))),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { GraphQLModule } from '@graphql-modules/core';\n\nexport interface MyModuleConfig {\n  secretKey: string;\n  remoteEndpoint: string;\n  someDbInstance: SomeDBInstance;\n}\n\n// You can access the config object like below inside the module declaration\nexport const MyModule = new GraphQLModule<MyModuleConfig>({\n  providers: ({ config: { someDbInstance } }) => [\n    MyProvider,\n    {\n      provide: SomeDbInstance,\n      useValue: someDbInstance,\n    },\n  ],\n});\n")),(0,r.kt)("p",null,"And to consume:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Injectable()\nexport class MyProvider {\n  constructor(@Inject(ModuleConfig) private config: MyModuleConfig) {\n    // ...\n  }\n}\n")))),(0,r.kt)("h2",{id:"session"},"Session"),(0,r.kt)("p",null,"In v0, we had a concept of Session to manage the execution of each operation. In v1, we dropped it, in favor of a simpler solution."),(0,r.kt)("p",null,"Internally, we are using Node's ",(0,r.kt)("inlineCode",{parentName:"p"},"async_hooks")," to manage a context of an execution, which allow us to share Injectables between Singleton and Operation scope."),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("p",null,"In v0, you could create a ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," per each module. In v1, ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," is external for GraphQL-Modules and it's not directly in use. You can do whatever you want with that, and just access it in GraphQL-Modules if you need, but we no longer require you to do specific things with your ",(0,r.kt)("inlineCode",{parentName:"p"},"context"),"."),(0,r.kt)(l.Z,{defaultValue:"1",values:[{label:"V1",value:"1"},{label:"V0",value:"0"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"1",mdxType:"TabItem"},(0,r.kt)("p",null,"With v1, you can manage your own ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," without anything special that needs to be done in order to GraphQL-Modules to work."),(0,r.kt)("p",null,"You can inject ",(0,r.kt)("inlineCode",{parentName:"p"},"CONTEXT")," in order to get access to the global execution context, and Modules you create doesn't take part in building that object.")),(0,r.kt)(i.Z,{value:"0",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const MyModule = new GraphQLModule({\n  context(session: MyModuleSession) {\n    session.res.on('finish', () => {\n      // Some cleanup\n    });\n    return {\n      authToken: session.req.headers.authorization,\n    };\n  },\n});\n")))),(0,r.kt)("h2",{id:"dependency-injection-scopes"},"Dependency Injection Scopes"),(0,r.kt)("p",null,"We decided to reduce the number of Scopes (from 3 to only 2) and change the names. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Session")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Request")," scopes are a bit misleading and hard to understand at first glimpse. "),(0,r.kt)("p",null,"In v1 it's much simpler, there are two Scopes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Singleton")," - Injectable is instantiated once, at bootstrap phase (",(0,r.kt)("inlineCode",{parentName:"li"},"createApplication"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Operation")," - Injectable is instantiated once per GraphQL Operation.")),(0,r.kt)("p",null,"In our opinion, it's much easier to reason about."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ProviderScope")," was renamed to just ",(0,r.kt)("inlineCode",{parentName:"p"},"Scope"),"."),(0,r.kt)("h2",{id:"dependency-injection-hierarchy"},"Dependency Injection Hierarchy"),(0,r.kt)("p",null,"With v1, the structure of your application is now flat, meaning there's an application level on top of a module level (many)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Application -> [ Module, Module, Module ]\n")),(0,r.kt)("p",null,"This change enables an abstraction that was not possible in v0. Your modules can depend on Injectables or InjectionTokens provided by Application."),(0,r.kt)("p",null,"We recommend to read ",(0,r.kt)("a",{parentName:"p",href:"../di/introduction/#hierarchical-injectors"},'"Hierarchical Injectors"')," chapter."))}v.isMDXComponent=!0}}]);