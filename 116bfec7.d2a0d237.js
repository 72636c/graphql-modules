(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{124:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return m}));var o=t(0),r=t.n(o);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),p=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=p(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=p(t),u=o,m=d["".concat(i,".").concat(u)]||d[u]||b[u]||a;return t?r.a.createElement(m,c(c({ref:n},l),{},{components:t})):r.a.createElement(m,c({ref:n},l))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=u;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var l=2;l<a;l++)i[l]=t[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},68:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var o=t(3),r=t(8),a=(t(0),t(124)),i={id:"dependency-injection",title:"Dependency Injection",sidebar_label:"Dependency Injection"},c={unversionedId:"introduction/dependency-injection",id:"version-legacy/introduction/dependency-injection",isDocsHomePage:!1,title:"Dependency Injection",description:"GraphQL Modules lets you use dependency injection among your modules, and lets you inject configs, functions, classes and instances into your modules.",source:"@site/versioned_docs/version-legacy/introduction/dependency-injection.md",slug:"/introduction/dependency-injection",permalink:"/docs/legacy/introduction/dependency-injection",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/versioned_docs/version-legacy/introduction/dependency-injection.md",version:"legacy",sidebar_label:"Dependency Injection",sidebar:"version-legacy/docs",previous:{title:"Dependencies Between Modules",permalink:"/docs/legacy/introduction/dependencies"},next:{title:"Module Configuration",permalink:"/docs/legacy/introduction/configuration"}},s=[{value:"Providers",id:"providers",children:[]},{value:"Import providers from other modules",id:"import-providers-from-other-modules",children:[]},{value:"Injection Tokens",id:"injection-tokens",children:[]},{value:"Custom Injectables",id:"custom-injectables",children:[{value:"Class",id:"class",children:[]},{value:"Value",id:"value",children:[]},{value:"Factory",id:"factory",children:[]}]},{value:"Hooks",id:"hooks",children:[{value:"<code>OnInit</code> hook",id:"oninit-hook",children:[]},{value:"<code>OnRequest</code> hook",id:"onrequest-hook",children:[]},{value:"<code>OnResponse</code> hook (experimental)",id:"onresponse-hook-experimental",children:[]},{value:"<code>OnError</code> hook (experimental)",id:"onerror-hook-experimental",children:[]},{value:"<code>OnConnect</code> hook",id:"onconnect-hook",children:[]},{value:"<code>OnDisconnect</code> hook",id:"ondisconnect-hook",children:[]}]},{value:"Provider Scopes",id:"provider-scopes",children:[{value:"Application Scope (by default)",id:"application-scope-by-default",children:[]},{value:"Session Scope",id:"session-scope",children:[]},{value:"Request Scope",id:"request-scope",children:[]}]},{value:"Built-in <code>ModuleSessionInfo</code> Provider",id:"built-in-modulesessioninfo-provider",children:[]}],l={rightToc:s};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"GraphQL Modules lets you use dependency injection among your modules, and lets you inject configs, functions, classes and instances into your modules."),Object(a.b)("p",null,"We expose a simple API that covers most use cases concerning backend modules."),Object(a.b)("p",null,"We learned not to force using dependency injection too early in the process, because dependency injection makes sense only in some specific use cases, and using it can be recommended only when your codebase is quite large and you need to move fast."),Object(a.b)("p",null,"GraphQL Modules lets you choose whether to use dependency injection or not."),Object(a.b)("h2",{id:"providers"},"Providers"),Object(a.b)("p",null,"Let's start by creating a simple class ",Object(a.b)("inlineCode",{parentName:"p"},"UserProvider")," with the ",Object(a.b)("inlineCode",{parentName:"p"},"@Injectable()")," decorator."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"modules/my-module/user.provider.ts")),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\n\n@Injectable()\nexport class UserProvider {}\n")),Object(a.b)("p",null,"Now, let's add this ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," to our ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLModule"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { GraphQLModule } from '@graphql-modules/core';\nimport * as typeDefs from './schema.graphql';\nimport resolvers from './resolvers';\nimport { UserProvider } from './user.provider';\n\nexport const MyModule = new GraphQLModule({\n  typeDefs,\n  resolvers,\n  providers: [UserProvider],\n});\n")),Object(a.b)("p",null,"Now, let's implement the ",Object(a.b)("inlineCode",{parentName:"p"},"Query.user")," resolver as a simple function inside ",Object(a.b)("inlineCode",{parentName:"p"},"UserProvider"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\n\n@Injectable()\nexport class UserProvider {\n  getUserById(id: string) {\n    return {\n      _id: id,\n      username: 'jhon',\n    };\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The lifecycle of a ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," is by default a singleton. So you can use the implemented functions as utility and still use ",Object(a.b)("inlineCode",{parentName:"p"},"this")," to save global variables.")),Object(a.b)("p",null,"To use this function from our Provider in the actual resolver implementation, get ",Object(a.b)("inlineCode",{parentName:"p"},"injector")," from ",Object(a.b)("inlineCode",{parentName:"p"},"context"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { ModuleContext } from '@graphql-modules/core';\n\nexport default {\n  Query: {\n    user: (_, { id }: { id: string }, { injector }: ModuleContext) =>\n      injector.get(UserProvider).getUserById(id),\n  },\n  User: {\n    id: (user) => user._id,\n    username: (user) => user.username,\n  },\n};\n")),Object(a.b)("p",null,"Now our resolver is just a proxy to our implementation: we can easily replace ",Object(a.b)("inlineCode",{parentName:"p"},"UserProvider")," with mocks during tests.\nWe can use ",Object(a.b)("inlineCode",{parentName:"p"},"UserProvider")," and ",Object(a.b)("inlineCode",{parentName:"p"},"getUserById")," from other modules."),Object(a.b)("h2",{id:"import-providers-from-other-modules"},"Import providers from other modules"),Object(a.b)("p",null,"To use ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," from other modules, you can just inject it using ",Object(a.b)("inlineCode",{parentName:"p"},"@Inject(INJECTION_TOKEN)"),"."),Object(a.b)("p",null,"Injection tokens are used just for identifying your value and fetching it from the available injectables.\nIt could be either ",Object(a.b)("inlineCode",{parentName:"p"},"class"),", ",Object(a.b)("inlineCode",{parentName:"p"},"string")," or ",Object(a.b)("inlineCode",{parentName:"p"},"Symbol"),"."),Object(a.b)("p",null,"To get ",Object(a.b)("inlineCode",{parentName:"p"},"OtherProvider")," from ",Object(a.b)("inlineCode",{parentName:"p"},"MyProvider"),", do the following:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OtherProvider } from '../my-other-module/other.provider';\n\n@Injectable()\nexport class MyProvider {\n  constructor(private otherProvider: OtherProvider) {}\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"We added ",Object(a.b)("inlineCode",{parentName:"p"},"private")," on the argument declaration; it's just a TypeScript trick to declare a class member and set it at the same time, and so now ",Object(a.b)("inlineCode",{parentName:"p"},"this.otherProvider")," is available to use.")),Object(a.b)("h2",{id:"injection-tokens"},"Injection Tokens"),Object(a.b)("p",null,"If you wish to decouple the actual class implementation and the injection token, you can create your own injection token and declare it this way:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"const MY_CLASS_TOKEN = 'myAwesomeClassIdentifier';\n\nexport const MyModule = new GraphQLModule({\n  providers: [{ provide: MY_CLASS_TOKEN, useClass: MyProvider }],\n});\n")),Object(a.b)("p",null,"This way, you can ask for the actual value of ",Object(a.b)("inlineCode",{parentName:"p"},"MY_CLASS_TOKEN")," from other providers, without knowing the specific implementation:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable, Inject } from '@graphql-modules/core';\n\ninterface IOtherProviderSignature {\n  doSomething: () => void;\n}\n\n@Injectable()\nexport class MyProvider {\n  constructor(\n    @Inject(MY_CLASS_TOKEN) private otherProvider: IOtherProviderSignature\n  ) {}\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"This is a very common and useful design pattern related to dependency injection. The power of TypeScript interfaces enables you to use it easily.")),Object(a.b)("h2",{id:"custom-injectables"},"Custom Injectables"),Object(a.b)("p",null,"You can also create custom ",Object(a.b)("inlineCode",{parentName:"p"},"Provider"),"s (which are non-classes) with injection tokens.\nIt's useful when you want your module to get something from outside with a specific signature.\nYou can use custom injection tokens to identify your injectables."),Object(a.b)("h3",{id:"class"},"Class"),Object(a.b)("p",null,"We have already learned how to provide classes:\njust specify the class in the list of ",Object(a.b)("inlineCode",{parentName:"p"},"providers")," in your module declaration."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"export const MyModule = new GraphQLModule({\n  providers: [UserProvider],\n});\n")),Object(a.b)("p",null,"Or use another class which has same interface."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"export class MyModule = new GraphQLModule({\n  providers: [\n    {\n      provide: SomeAbstractClass,\n      useClass: MyImplementation,\n    }\n  ]\n});\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The lifecycle of a class provider is a singleton by default, i.e. they are created only once and you are using the same instance for all GraphQL executions. But you can change the lifecycle using ",Object(a.b)("strong",{parentName:"p"},"Provider Scopes"),".")),Object(a.b)("h3",{id:"value"},"Value"),Object(a.b)("p",null,"Value providers are an easy way to pass an existing instance of ",Object(a.b)("inlineCode",{parentName:"p"},"class")," or any other value that you wish to make available to ",Object(a.b)("inlineCode",{parentName:"p"},"@Inject"),"."),Object(a.b)("p",null,"You can use any value, and attach it to an injection token."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"const MY_VALUE = 'myUsefulValue';\n\nexport const MyModule = new GraphQLModule({\n  providers: [\n    {\n      provide: MY_VALUE,\n      useValue: 'Hello!',\n    },\n  ],\n});\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"You can use value injectables to inject instances and global injectables, such as ",Object(a.b)("inlineCode",{parentName:"p"},"Logger")," instance, database connection/collections, secret tokens etc.")),Object(a.b)("h3",{id:"factory"},"Factory"),Object(a.b)("p",null,"Factories provide another way to pass an instance of ",Object(a.b)("inlineCode",{parentName:"p"},"provider"),". The return value of the factory function is used as the value of the provider."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"const MY_VALUE = 'myUsefulVal8e';\n\nexport const MyModule = new GraphQLModule({\n  providers: [\n    {\n      provide: MY_VALUE,\n      useFactory: () => {\n        // some extra logic\n        return myValue;\n      },\n    },\n  ],\n});\n")),Object(a.b)("h2",{id:"hooks"},"Hooks"),Object(a.b)("h3",{id:"oninit-hook"},Object(a.b)("inlineCode",{parentName:"h3"},"OnInit")," hook"),Object(a.b)("p",null,"This hook is called once when your application is started."),Object(a.b)("p",null,"Example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OnInit } from '@graphql-modules/core';\n@Injectable()\nexport class DatabaseProvider implements OnInit {\n  constructor(private dbClient: DbClient) {}\n  onInit() {\n    this.dbClient.connect();\n    console.info('Database Client is connected!');\n  }\n}\n")),Object(a.b)("h3",{id:"onrequest-hook"},Object(a.b)("inlineCode",{parentName:"h3"},"OnRequest")," hook"),Object(a.b)("p",null,"By defining this hook as a method in your class provider, you can get access to useful information: the top ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLModule")," instance, GraphQL Context, and the network session."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OnRequest } from '@graphql-modules/core';\n\nExample;\n\n@Injectable({\n  scope: ProviderScope.Session,\n})\nexport class AuthProvider implements OnRequest {\n  userId: string;\n  onRequest(moduleSessionInfo: ModuleSessionInfo) {\n    // ... do your magic ...\n    // Let's assume you have your network request object under req property of network session\n    const authToken = moduleSessionInfo.session.req.headers.authentication;\n    this.userId = someFnForTokenExchange(authToken);\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The ",Object(a.b)("inlineCode",{parentName:"p"},"OnRequest")," hook is called on each HTTP GraphQL request with a single ",Object(a.b)("inlineCode",{parentName:"p"},"ModuleSessionInfo")," parameter.")),Object(a.b)("h3",{id:"onresponse-hook-experimental"},Object(a.b)("inlineCode",{parentName:"h3"},"OnResponse")," hook (experimental)"),Object(a.b)("p",null,"It takes the same parameter as the ",Object(a.b)("inlineCode",{parentName:"p"},"OnRequest")," hook but gets called right before the server sends the HTTP response to the client."),Object(a.b)("p",null,"Example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OnResponse } from '@graphql-modules/core';\n\n@Injectable()\nexport class MyProvider implements OnResponse {\n  onResponse(moduleSessionInfo: ModuleSessionInfo) {\n    // ... do your magic ...\n    clearDatabasePool(moduleSessionInfo.session);\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The ",Object(a.b)("inlineCode",{parentName:"p"},"OnResponse")," hook is called on each HTTP GraphQL request with a single ",Object(a.b)("inlineCode",{parentName:"p"},"ModuleSessionInfo")," parameter.")),Object(a.b)("h3",{id:"onerror-hook-experimental"},Object(a.b)("inlineCode",{parentName:"h3"},"OnError")," hook (experimental)"),Object(a.b)("p",null,"It takes one parameter of the type ",Object(a.b)("inlineCode",{parentName:"p"},"Error"),"; it gets called when any error is thrown during execution of resolvers."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OnError } from '@graphql-modules/core';\n\n@Injectable()\nexport class MyProvider implements OnError {\n  onError(error: Error) {\n    // ... do your magic ...\n    logError(error.message);\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"This hook is not called if there is an error on dependency injection or context building because then dependency injection completely stops.")),Object(a.b)("h3",{id:"onconnect-hook"},Object(a.b)("inlineCode",{parentName:"h3"},"OnConnect")," hook"),Object(a.b)("p",null,"This hook is similar to ",Object(a.b)("inlineCode",{parentName:"p"},"OnRequest")," but it is called on the initialization of the WebSocket connection.\nIt is exactly the same with the ",Object(a.b)("inlineCode",{parentName:"p"},"OnConnect")," hook passed to ",Object(a.b)("inlineCode",{parentName:"p"},"subscriptions")," in ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",Object(o.a)({parentName:"strong"},{href:"https://github.com/apollographql/subscriptions-transport-ws"}),"SubscriptionServer")),"."),Object(a.b)("p",null,"See also ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",Object(o.a)({parentName:"strong"},{href:"https://www.apollographql.com/docs/graphql-subscriptions/authentication.html"}),"Apollo document on authentication over WebSocket")),"."),Object(a.b)("p",null,"Example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OnConnect } from '@graphql-modules/core';\n\n@Injectable({\n  scope: ProviderScope.Session,\n})\nexport class AuthProvider implements OnConnect {\n  userId: string;\n  onConnect(connectionParams) {\n    // ... do your magic ...\n    const authToken = connectionParams.authentication;\n    this.userId = someFnForTokenExchange(authToken);\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The ",Object(a.b)("inlineCode",{parentName:"p"},"OnConnect")," hook is called once for each WebSocket GraphQL connection.")),Object(a.b)("h3",{id:"ondisconnect-hook"},Object(a.b)("inlineCode",{parentName:"h3"},"OnDisconnect")," hook"),Object(a.b)("p",null,"This hook is similar to ",Object(a.b)("inlineCode",{parentName:"p"},"OnResponse")," but it is called on the termination of the WebSocket connection.\nIt is exactly the same as the ",Object(a.b)("inlineCode",{parentName:"p"},"OnDisconnect")," hook passed to ",Object(a.b)("inlineCode",{parentName:"p"},"subscriptions")," in ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",Object(o.a)({parentName:"strong"},{href:"https://github.com/apollographql/subscriptions-transport-ws"}),"SubscriptionServer")),"."),Object(a.b)("p",null,"See also ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",Object(o.a)({parentName:"strong"},{href:"https://www.apollographql.com/docs/graphql-subscriptions/authentication.html"}),"Apollo document on authentication over WebSocket")),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable } from '@graphql-modules/di';\nimport { OnDisconnect } from '@graphql-modules/core';\n\n@Injectable()\nexport class MyProvider implements OnDisconnect {\n  onDisconnect(connectionParams, webSocket) {\n    // ... do your magic ...\n    clearSomeSubscriptions(moduleSessionInfo.session);\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The ",Object(a.b)("inlineCode",{parentName:"p"},"OnDisconnect")," hook is called once for each WebSocket GraphQL connection.")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"The other ",Object(a.b)("inlineCode",{parentName:"p"},"OnOperation")," and ",Object(a.b)("inlineCode",{parentName:"p"},"OnOperationComplete")," hooks work similarly to the GraphQL Subscription Server implementation.\nSee also ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",Object(o.a)({parentName:"strong"},{href:"https://github.com/apollographql/subscriptions-transport-ws"}),"the document of subscriptions-transport-ws")),".")),Object(a.b)("h2",{id:"provider-scopes"},"Provider Scopes"),Object(a.b)("p",null,"You can define different lifecycles for your provider. You have three options."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable, ProviderScope } from '@graphql-modules/di';\n@Injectable({\n  scope:\n    ProviderScope.Application | ProviderScope.Session | ProviderScope.Request,\n})\nexport class MyProvider {}\n")),Object(a.b)("p",null,"See also ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",Object(o.a)({parentName:"strong"},{href:"https://medium.com/the-guild/scoped-providers-in-graphql-modules-dependency-injection-system-949cd2588e0"}),"Scoped Providers in GraphQL Modules Dependency Injection")),"."),Object(a.b)("h3",{id:"application-scope-by-default"},"Application Scope (by default)"),Object(a.b)("p",null,"If you define a provider in this scope (which is default), the provider will be instantiated on the application start and remain the same in the entire application and all the following requests.\nThe providers in this scope can be considered as a shared state across all users\u2019 interactions with our application.\nIt basically means that the instance will be treated as a ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Singleton_pattern"}),"singleton"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { Injectable, ProviderScope } from '@graphql-modules/di';\n@Injectable({\n  scope: ProviderScope.Application,\n})\nexport class MyProvider {}\n")),Object(a.b)("h3",{id:"session-scope"},"Session Scope"),Object(a.b)("p",null,"When a network request arrives at your GraphQL server, the GraphQL server calls the context factory of the parent module.\nThe parent module creates a session injector and instantiates session-scoped providers with the session object which contains the current context, session injector and network request.\nThis session object is passed through the module's resolvers using the module's context."),Object(a.b)("p",null,"In other words, providers defined in the session scope are constructed at the start of the network request and then kept until the network request is closed.\nWhereas application-scoped providers are kept during the application runtime and shared between all the following network requests and resolvers in the requests, this type of providers would not be shared between different requests; in resolver calls those belong to the same network request."),Object(a.b)("p",null,"This session scope is kept on memory for all the following network requests of the same connection if the connection uses WebSocket. For regular HTTP, it is terminated immediately."),Object(a.b)("h3",{id:"request-scope"},"Request Scope"),Object(a.b)("p",null,"If you have request-scope'd providers in your GraphQL Module, these providers are generated in every injection.\nThis means a request-scoped provider is never kept by neither the application state, nor the session state.\nSo this type of providers works just like a ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Factory_method_pattern"}),"factory"),".\nIt creates an instance each time you request from the injector."),Object(a.b)("h2",{id:"built-in-modulesessioninfo-provider"},"Built-in ",Object(a.b)("inlineCode",{parentName:"h2"},"ModuleSessionInfo")," Provider"),Object(a.b)("p",null,"Every GraphQL-Module creates on each network request a ",Object(a.b)("inlineCode",{parentName:"p"},"ModuleSessionInfo")," instance that contains the raw request from the GraphQL Server, the ",Object(a.b)("inlineCode",{parentName:"p"},"SessionInjector")," with session-scoped instances and application-scoped instances, and the ",Object(a.b)("inlineCode",{parentName:"p"},"Context")," object constructed by ",Object(a.b)("inlineCode",{parentName:"p"},"contextBuilder")," of the module.\nNote that you cannot use this built-in provider in the application scope."))}p.isMDXComponent=!0}}]);